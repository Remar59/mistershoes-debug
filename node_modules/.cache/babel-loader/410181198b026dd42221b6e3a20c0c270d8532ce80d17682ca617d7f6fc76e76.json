{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"resolveHref\", {\n  enumerable: true,\n  get: function () {\n    return resolveHref;\n  }\n});\nconst _querystring = require(\"../shared/lib/router/utils/querystring\");\nconst _formaturl = require(\"../shared/lib/router/utils/format-url\");\nconst _omit = require(\"../shared/lib/router/utils/omit\");\nconst _utils = require(\"../shared/lib/utils\");\nconst _normalizetrailingslash = require(\"./normalize-trailing-slash\");\nconst _islocalurl = require(\"../shared/lib/router/utils/is-local-url\");\nconst _utils1 = require(\"../shared/lib/router/utils\");\nconst _interpolateas = require(\"../shared/lib/router/utils/interpolate-as\");\nfunction resolveHref(router, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  let base;\n  let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n  // repeated slashes and backslashes in the URL are considered\n  // invalid and will never match a Next.js page/file\n  const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n  const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n  const urlParts = urlAsStringNoProto.split(\"?\", 1);\n  if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n    console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n    const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n  }\n  // Return because it cannot be routed by the Next.js router\n  if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n  try {\n    base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n  } catch (_) {\n    // fallback to / for invalid asPath values e.g. //\n    base = new URL(\"/\", \"http://n\");\n  }\n  try {\n    const finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n    let interpolatedAs = \"\";\n    if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n      const {\n        result,\n        params\n      } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n      if (result) {\n        interpolatedAs = (0, _formaturl.formatWithValidation)({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: (0, _omit.omit)(query, params)\n        });\n      }\n    }\n    // if the origin didn't change, it means we received a relative href\n    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"mappings":";;;;;+BAyBgBA;;;WAAAA;;;6BAvBuB;2BACF;sBAChB;uBACoB;wCACE;4BAChB;wBACI;+BACD;AAgBvB,SAASA,YACdC,MAAkB,EAClBC,IAAS,EACTC,SAAmB;EAEnB;EACA,IAAIC;EACJ,IAAIC,cAAc,OAAOH,SAAS,WAAWA,OAAOI,mCAAoB,EAACJ;EAEzE;EACA;EACA,MAAMK,gBAAgBF,YAAYG,KAAK,CAAC;EACxC,MAAMC,qBAAqBF,gBACvBF,YAAYK,KAAK,CAACH,aAAa,CAAC,EAAE,CAACI,MAAM,IACzCN;EAEJ,MAAMO,WAAWH,mBAAmBI,KAAK,CAAC,KAAK;EAE/C,IAAI,CAACD,QAAQ,CAAC,EAAE,IAAI,EAAC,EAAGJ,KAAK,CAAC,cAAc;IAC1CM,QAAQC,KAAK,CACX,gBAAC,GAAgBV,cAAY,uCAAoCJ,OAAOe,QAAQ,GAAC;IAEnF,MAAMC,gBAAgBC,mCAAwB,EAACT;IAC/CJ,cAAc,CAACE,gBAAgBA,aAAa,CAAC,EAAE,GAAG,EAAC,IAAKU;EAC1D;EAEA;EACA,IAAI,CAACE,0BAAU,EAACd,cAAc;IAC5B,OAAQF,YAAY,CAACE,YAAY,GAAGA;EACtC;EAEA,IAAI;IACFD,OAAO,IAAIgB,IACTf,YAAYgB,UAAU,CAAC,OAAOpB,OAAOqB,MAAM,GAAGrB,OAAOe,QAAQ,EAC7D;EAEJ,EAAE,OAAOO,GAAG;IACV;IACAnB,OAAO,IAAIgB,IAAI,KAAK;EACtB;EAEA,IAAI;IACF,MAAMI,WAAW,IAAIJ,IAAIf,aAAaD;IACtCoB,SAASR,QAAQ,GAAGS,sDAA0B,EAACD,SAASR,QAAQ;IAChE,IAAIU,iBAAiB;IAErB,IACEC,0BAAc,EAACH,SAASR,QAAQ,KAChCQ,SAASI,YAAY,IACrBzB,WACA;MACA,MAAM0B,QAAQC,uCAAsB,EAACN,SAASI,YAAY;MAE1D,MAAM;QAAEG,MAAM;QAAEC;MAAM,CAAE,GAAGC,gCAAa,EACtCT,SAASR,QAAQ,EACjBQ,SAASR,QAAQ,EACjBa;MAGF,IAAIE,QAAQ;QACVL,iBAAiBpB,mCAAoB,EAAC;UACpCU,UAAUe;UACVG,MAAMV,SAASU,IAAI;UACnBL,OAAOM,cAAI,EAACN,OAAOG;QACrB;MACF;IACF;IAEA;IACA,MAAMI,eACJZ,SAASa,MAAM,KAAKjC,KAAKiC,MAAM,GAC3Bb,SAAStB,IAAI,CAACQ,KAAK,CAACc,SAASa,MAAM,CAAC1B,MAAM,IAC1Ca,SAAStB,IAAI;IAEnB,OAAOC,YACH,CAACiC,cAAcV,kBAAkBU,aAAa,GAC9CA;EACN,EAAE,OAAOb,GAAG;IACV,OAAOpB,YAAY,CAACE,YAAY,GAAGA;EACrC;AACF","names":["resolveHref","router","href","resolveAs","base","urlAsString","formatWithValidation","urlProtoMatch","match","urlAsStringNoProto","slice","length","urlParts","split","console","error","pathname","normalizedUrl","normalizeRepeatedSlashes","isLocalURL","URL","startsWith","asPath","_","finalUrl","normalizePathTrailingSlash","interpolatedAs","isDynamicRoute","searchParams","query","searchParamsToUrlQuery","result","params","interpolateAs","hash","omit","resolvedHref","origin"],"sources":["../../src/client/resolve-href.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}