{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  INTERCEPTION_ROUTE_MARKERS: null,\n  isInterceptionRouteAppPath: null,\n  extractInterceptionRouteInformation: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  INTERCEPTION_ROUTE_MARKERS: function () {\n    return INTERCEPTION_ROUTE_MARKERS;\n  },\n  isInterceptionRouteAppPath: function () {\n    return isInterceptionRouteAppPath;\n  },\n  extractInterceptionRouteInformation: function () {\n    return extractInterceptionRouteInformation;\n  }\n});\nconst _apppaths = require(\"../../../shared/lib/router/utils/app-paths\");\nconst INTERCEPTION_ROUTE_MARKERS = [\"(..)(..)\", \"(.)\", \"(..)\", \"(...)\"];\nfunction isInterceptionRouteAppPath(path) {\n  // TODO-APP: add more serious validation\n  return path.split(\"/\").find(segment => INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m))) !== undefined;\n}\nfunction extractInterceptionRouteInformation(path) {\n  let interceptingRoute, marker, interceptedRoute;\n  for (const segment of path.split(\"/\")) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m));\n    if (marker) {\n      [interceptingRoute, interceptedRoute] = path.split(marker, 2);\n      break;\n    }\n  }\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`);\n  }\n  interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n  ;\n\n  switch (marker) {\n    case \"(.)\":\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === \"/\") {\n        interceptedRoute = `/${interceptedRoute}`;\n      } else {\n        interceptedRoute = interceptingRoute + \"/\" + interceptedRoute;\n      }\n      break;\n    case \"(..)\":\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === \"/\") {\n        throw new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`);\n      }\n      interceptedRoute = interceptingRoute.split(\"/\").slice(0, -1).concat(interceptedRoute).join(\"/\");\n      break;\n    case \"(...)\":\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = \"/\" + interceptedRoute;\n      break;\n    case \"(..)(..)\":\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n      const splitInterceptingRoute = interceptingRoute.split(\"/\");\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`);\n      }\n      interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join(\"/\");\n      break;\n    default:\n      throw new Error(\"Invariant: unexpected marker\");\n  }\n  return {\n    interceptingRoute,\n    interceptedRoute\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;EAGaA,0BAA0B;WAA1BA;;EAOGC,0BAA0B;WAA1BA;;EAWAC,mCAAmC;WAAnCA;;;0BArBiB;AAG1B,MAAMF,6BAA6B,CACxC,YACA,OACA,QACA,QACD;AAEM,SAASC,2BAA2BE,IAAY;EACrD;EACA,OACEA,KACGC,KAAK,CAAC,KACNC,IAAI,CAAEC,WACLN,2BAA2BK,IAAI,CAAEE,KAAMD,QAAQE,UAAU,CAACD,SACtDE;AAEZ;AAEO,SAASP,oCAAoCC,IAAY;EAC9D,IAAIO,mBACFC,QACAC;EAEF,KAAK,MAAMN,WAAWH,KAAKC,KAAK,CAAC,MAAM;IACrCO,SAASX,2BAA2BK,IAAI,CAAEE,KAAMD,QAAQE,UAAU,CAACD;IACnE,IAAII,QAAQ;MACT,CAACD,mBAAmBE,iBAAiB,GAAGT,KAAKC,KAAK,CAACO,QAAQ;MAC5D;IACF;EACF;EAEA,IAAI,CAACD,qBAAqB,CAACC,UAAU,CAACC,kBAAkB;IACtD,MAAM,IAAIC,MACP,+BAA8BV,IAAK,mFAAkF;EAE1H;EAEAO,oBAAoBI,8BAAgB,EAACJ,mBAAmB;EAAA;;EAExD,QAAQC;IACN,KAAK;MACH;MACA,IAAID,sBAAsB,KAAK;QAC7BE,mBAAoB,IAAGA,gBAAiB,EAAC;MAC3C,OAAO;QACLA,mBAAmBF,oBAAoB,MAAME;MAC/C;MACA;IACF,KAAK;MACH;MACA,IAAIF,sBAAsB,KAAK;QAC7B,MAAM,IAAIG,MACP,+BAA8BV,IAAK,8DAA6D;MAErG;MACAS,mBAAmBF,kBAChBN,KAAK,CAAC,KACNW,KAAK,CAAC,GAAG,CAAC,GACVC,MAAM,CAACJ,kBACPK,IAAI,CAAC;MACR;IACF,KAAK;MACH;MACAL,mBAAmB,MAAMA;MACzB;IACF,KAAK;MACH;MAEA,MAAMM,yBAAyBR,kBAAkBN,KAAK,CAAC;MACvD,IAAIc,uBAAuBC,MAAM,IAAI,GAAG;QACtC,MAAM,IAAIN,MACP,+BAA8BV,IAAK,iEAAgE;MAExG;MAEAS,mBAAmBM,uBAChBH,KAAK,CAAC,GAAG,CAAC,GACVC,MAAM,CAACJ,kBACPK,IAAI,CAAC;MACR;IACF;MACE,MAAM,IAAIJ,MAAM;EAAA;EAGpB,OAAO;IAAEH;IAAmBE;EAAiB;AAC/C","names":["INTERCEPTION_ROUTE_MARKERS","isInterceptionRouteAppPath","extractInterceptionRouteInformation","path","split","find","segment","m","startsWith","undefined","interceptingRoute","marker","interceptedRoute","Error","normalizeAppPath","slice","concat","join","splitInterceptingRoute","length"],"sources":["../../../../src/server/future/helpers/interception-routes.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}